// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.0
// - protoc             v3.21.12
// source: v1/embedding_svc.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	v1 "rag/api/common/v1"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationEmbeddingComputeSimilarity = "/api.embedding.v1.Embedding/ComputeSimilarity"
const OperationEmbeddingEmbedBatch = "/api.embedding.v1.Embedding/EmbedBatch"
const OperationEmbeddingEmbedBatchAsync = "/api.embedding.v1.Embedding/EmbedBatchAsync"
const OperationEmbeddingEmbedText = "/api.embedding.v1.Embedding/EmbedText"
const OperationEmbeddingGetEmbeddingTaskStatus = "/api.embedding.v1.Embedding/GetEmbeddingTaskStatus"
const OperationEmbeddingGetModelInfo = "/api.embedding.v1.Embedding/GetModelInfo"
const OperationEmbeddingHealthCheck = "/api.embedding.v1.Embedding/HealthCheck"
const OperationEmbeddingListModels = "/api.embedding.v1.Embedding/ListModels"

type EmbeddingHTTPServer interface {
	// ComputeSimilarity 计算相似度
	ComputeSimilarity(context.Context, *ComputeSimilarityRequest) (*ComputeSimilarityResponse, error)
	// EmbedBatch 批量向量化
	EmbedBatch(context.Context, *EmbedBatchRequest) (*EmbedBatchResponse, error)
	// EmbedBatchAsync 异步批量向量化
	EmbedBatchAsync(context.Context, *EmbedBatchAsyncRequest) (*EmbedBatchAsyncResponse, error)
	// EmbedText 文本向量化
	EmbedText(context.Context, *EmbedTextRequest) (*EmbedTextResponse, error)
	// GetEmbeddingTaskStatus 获取异步任务状态
	GetEmbeddingTaskStatus(context.Context, *GetEmbeddingTaskStatusRequest) (*GetEmbeddingTaskStatusResponse, error)
	// GetModelInfo 获取模型信息
	GetModelInfo(context.Context, *GetModelInfoRequest) (*GetModelInfoResponse, error)
	// HealthCheck 健康检查
	HealthCheck(context.Context, *emptypb.Empty) (*v1.HealthCheckResponse, error)
	// ListModels 列出可用模型
	ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error)
}

func RegisterEmbeddingHTTPServer(s *http.Server, srv EmbeddingHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/embed/text", _Embedding_EmbedText0_HTTP_Handler(srv))
	r.POST("/v1/embed/batch", _Embedding_EmbedBatch0_HTTP_Handler(srv))
	r.POST("/v1/embed/batch-async", _Embedding_EmbedBatchAsync0_HTTP_Handler(srv))
	r.GET("/v1/embed/tasks/{task_id}", _Embedding_GetEmbeddingTaskStatus0_HTTP_Handler(srv))
	r.GET("/v1/models/{model_name}", _Embedding_GetModelInfo0_HTTP_Handler(srv))
	r.GET("/v1/models", _Embedding_ListModels0_HTTP_Handler(srv))
	r.POST("/v1/similarity", _Embedding_ComputeSimilarity0_HTTP_Handler(srv))
	r.GET("/v1/health", _Embedding_HealthCheck0_HTTP_Handler(srv))
}

func _Embedding_EmbedText0_HTTP_Handler(srv EmbeddingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in EmbedTextRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmbeddingEmbedText)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.EmbedText(ctx, req.(*EmbedTextRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*EmbedTextResponse)
		return ctx.Result(200, reply)
	}
}

func _Embedding_EmbedBatch0_HTTP_Handler(srv EmbeddingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in EmbedBatchRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmbeddingEmbedBatch)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.EmbedBatch(ctx, req.(*EmbedBatchRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*EmbedBatchResponse)
		return ctx.Result(200, reply)
	}
}

func _Embedding_EmbedBatchAsync0_HTTP_Handler(srv EmbeddingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in EmbedBatchAsyncRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmbeddingEmbedBatchAsync)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.EmbedBatchAsync(ctx, req.(*EmbedBatchAsyncRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*EmbedBatchAsyncResponse)
		return ctx.Result(200, reply)
	}
}

func _Embedding_GetEmbeddingTaskStatus0_HTTP_Handler(srv EmbeddingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetEmbeddingTaskStatusRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmbeddingGetEmbeddingTaskStatus)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetEmbeddingTaskStatus(ctx, req.(*GetEmbeddingTaskStatusRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetEmbeddingTaskStatusResponse)
		return ctx.Result(200, reply)
	}
}

func _Embedding_GetModelInfo0_HTTP_Handler(srv EmbeddingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetModelInfoRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmbeddingGetModelInfo)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetModelInfo(ctx, req.(*GetModelInfoRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetModelInfoResponse)
		return ctx.Result(200, reply)
	}
}

func _Embedding_ListModels0_HTTP_Handler(srv EmbeddingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListModelsRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmbeddingListModels)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListModels(ctx, req.(*ListModelsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListModelsResponse)
		return ctx.Result(200, reply)
	}
}

func _Embedding_ComputeSimilarity0_HTTP_Handler(srv EmbeddingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ComputeSimilarityRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmbeddingComputeSimilarity)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ComputeSimilarity(ctx, req.(*ComputeSimilarityRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ComputeSimilarityResponse)
		return ctx.Result(200, reply)
	}
}

func _Embedding_HealthCheck0_HTTP_Handler(srv EmbeddingHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in emptypb.Empty
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmbeddingHealthCheck)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.HealthCheck(ctx, req.(*emptypb.Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.HealthCheckResponse)
		return ctx.Result(200, reply)
	}
}

type EmbeddingHTTPClient interface {
	// ComputeSimilarity 计算相似度
	ComputeSimilarity(ctx context.Context, req *ComputeSimilarityRequest, opts ...http.CallOption) (rsp *ComputeSimilarityResponse, err error)
	// EmbedBatch 批量向量化
	EmbedBatch(ctx context.Context, req *EmbedBatchRequest, opts ...http.CallOption) (rsp *EmbedBatchResponse, err error)
	// EmbedBatchAsync 异步批量向量化
	EmbedBatchAsync(ctx context.Context, req *EmbedBatchAsyncRequest, opts ...http.CallOption) (rsp *EmbedBatchAsyncResponse, err error)
	// EmbedText 文本向量化
	EmbedText(ctx context.Context, req *EmbedTextRequest, opts ...http.CallOption) (rsp *EmbedTextResponse, err error)
	// GetEmbeddingTaskStatus 获取异步任务状态
	GetEmbeddingTaskStatus(ctx context.Context, req *GetEmbeddingTaskStatusRequest, opts ...http.CallOption) (rsp *GetEmbeddingTaskStatusResponse, err error)
	// GetModelInfo 获取模型信息
	GetModelInfo(ctx context.Context, req *GetModelInfoRequest, opts ...http.CallOption) (rsp *GetModelInfoResponse, err error)
	// HealthCheck 健康检查
	HealthCheck(ctx context.Context, req *emptypb.Empty, opts ...http.CallOption) (rsp *v1.HealthCheckResponse, err error)
	// ListModels 列出可用模型
	ListModels(ctx context.Context, req *ListModelsRequest, opts ...http.CallOption) (rsp *ListModelsResponse, err error)
}

type EmbeddingHTTPClientImpl struct {
	cc *http.Client
}

func NewEmbeddingHTTPClient(client *http.Client) EmbeddingHTTPClient {
	return &EmbeddingHTTPClientImpl{client}
}

// ComputeSimilarity 计算相似度
func (c *EmbeddingHTTPClientImpl) ComputeSimilarity(ctx context.Context, in *ComputeSimilarityRequest, opts ...http.CallOption) (*ComputeSimilarityResponse, error) {
	var out ComputeSimilarityResponse
	pattern := "/v1/similarity"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEmbeddingComputeSimilarity))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// EmbedBatch 批量向量化
func (c *EmbeddingHTTPClientImpl) EmbedBatch(ctx context.Context, in *EmbedBatchRequest, opts ...http.CallOption) (*EmbedBatchResponse, error) {
	var out EmbedBatchResponse
	pattern := "/v1/embed/batch"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEmbeddingEmbedBatch))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// EmbedBatchAsync 异步批量向量化
func (c *EmbeddingHTTPClientImpl) EmbedBatchAsync(ctx context.Context, in *EmbedBatchAsyncRequest, opts ...http.CallOption) (*EmbedBatchAsyncResponse, error) {
	var out EmbedBatchAsyncResponse
	pattern := "/v1/embed/batch-async"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEmbeddingEmbedBatchAsync))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// EmbedText 文本向量化
func (c *EmbeddingHTTPClientImpl) EmbedText(ctx context.Context, in *EmbedTextRequest, opts ...http.CallOption) (*EmbedTextResponse, error) {
	var out EmbedTextResponse
	pattern := "/v1/embed/text"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEmbeddingEmbedText))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetEmbeddingTaskStatus 获取异步任务状态
func (c *EmbeddingHTTPClientImpl) GetEmbeddingTaskStatus(ctx context.Context, in *GetEmbeddingTaskStatusRequest, opts ...http.CallOption) (*GetEmbeddingTaskStatusResponse, error) {
	var out GetEmbeddingTaskStatusResponse
	pattern := "/v1/embed/tasks/{task_id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEmbeddingGetEmbeddingTaskStatus))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// GetModelInfo 获取模型信息
func (c *EmbeddingHTTPClientImpl) GetModelInfo(ctx context.Context, in *GetModelInfoRequest, opts ...http.CallOption) (*GetModelInfoResponse, error) {
	var out GetModelInfoResponse
	pattern := "/v1/models/{model_name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEmbeddingGetModelInfo))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// HealthCheck 健康检查
func (c *EmbeddingHTTPClientImpl) HealthCheck(ctx context.Context, in *emptypb.Empty, opts ...http.CallOption) (*v1.HealthCheckResponse, error) {
	var out v1.HealthCheckResponse
	pattern := "/v1/health"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEmbeddingHealthCheck))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListModels 列出可用模型
func (c *EmbeddingHTTPClientImpl) ListModels(ctx context.Context, in *ListModelsRequest, opts ...http.CallOption) (*ListModelsResponse, error) {
	var out ListModelsResponse
	pattern := "/v1/models"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEmbeddingListModels))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
