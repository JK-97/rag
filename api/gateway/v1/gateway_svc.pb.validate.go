// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: v1/gateway_svc.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUsername()) < 1 {
		err := LoginRequestValidationError{
			field:  "Username",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 1 {
		err := LoginRequestValidationError{
			field:  "Password",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ClientId

	// no validation rules for ClientSecret

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on LoginResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResponseMultiError, or
// nil if none found.
func (m *LoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for RefreshToken

	// no validation rules for TokenType

	// no validation rules for ExpiresIn

	// no validation rules for Scope

	if all {
		switch v := interface{}(m.GetUserInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginResponseValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginResponseValidationError{
					field:  "UserInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginResponseValidationError{
				field:  "UserInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginResponseMultiError(errors)
	}

	return nil
}

// LoginResponseMultiError is an error wrapping multiple validation errors
// returned by LoginResponse.ValidateAll() if the designated constraints
// aren't met.
type LoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginResponseMultiError) AllErrors() []error { return m }

// LoginResponseValidationError is the validation error returned by
// LoginResponse.Validate if the designated constraints aren't met.
type LoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginResponseValidationError) ErrorName() string { return "LoginResponseValidationError" }

// Error satisfies the builtin error interface
func (e LoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginResponseValidationError{}

// Validate checks the field values on RefreshTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTokenRequestMultiError, or nil if none found.
func (m *RefreshTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRefreshToken()) < 1 {
		err := RefreshTokenRequestValidationError{
			field:  "RefreshToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RefreshTokenRequestMultiError(errors)
	}

	return nil
}

// RefreshTokenRequestMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenRequest.ValidateAll() if the designated
// constraints aren't met.
type RefreshTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenRequestMultiError) AllErrors() []error { return m }

// RefreshTokenRequestValidationError is the validation error returned by
// RefreshTokenRequest.Validate if the designated constraints aren't met.
type RefreshTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenRequestValidationError) ErrorName() string {
	return "RefreshTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenRequestValidationError{}

// Validate checks the field values on RefreshTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTokenResponseMultiError, or nil if none found.
func (m *RefreshTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for RefreshToken

	// no validation rules for TokenType

	// no validation rules for ExpiresIn

	if len(errors) > 0 {
		return RefreshTokenResponseMultiError(errors)
	}

	return nil
}

// RefreshTokenResponseMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type RefreshTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenResponseMultiError) AllErrors() []error { return m }

// RefreshTokenResponseValidationError is the validation error returned by
// RefreshTokenResponse.Validate if the designated constraints aren't met.
type RefreshTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenResponseValidationError) ErrorName() string {
	return "RefreshTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenResponseValidationError{}

// Validate checks the field values on UserInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoMultiError, or nil
// if none found.
func (m *UserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Username

	// no validation rules for Email

	// no validation rules for Attributes

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastLoginAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "LastLoginAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserInfoValidationError{
					field:  "LastLoginAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastLoginAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserInfoValidationError{
				field:  "LastLoginAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserInfoMultiError(errors)
	}

	return nil
}

// UserInfoMultiError is an error wrapping multiple validation errors returned
// by UserInfo.ValidateAll() if the designated constraints aren't met.
type UserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoMultiError) AllErrors() []error { return m }

// UserInfoValidationError is the validation error returned by
// UserInfo.Validate if the designated constraints aren't met.
type UserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoValidationError) ErrorName() string { return "UserInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoValidationError{}

// Validate checks the field values on QueryRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryRequestMultiError, or
// nil if none found.
func (m *QueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetQuery()) < 1 {
		err := QueryRequestValidationError{
			field:  "Query",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SessionId

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryRequestValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryRequestValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryRequestValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	if len(errors) > 0 {
		return QueryRequestMultiError(errors)
	}

	return nil
}

// QueryRequestMultiError is an error wrapping multiple validation errors
// returned by QueryRequest.ValidateAll() if the designated constraints aren't met.
type QueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryRequestMultiError) AllErrors() []error { return m }

// QueryRequestValidationError is the validation error returned by
// QueryRequest.Validate if the designated constraints aren't met.
type QueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryRequestValidationError) ErrorName() string { return "QueryRequestValidationError" }

// Error satisfies the builtin error interface
func (e QueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryRequestValidationError{}

// Validate checks the field values on QueryParameters with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *QueryParameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryParameters with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryParametersMultiError, or nil if none found.
func (m *QueryParameters) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryParameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if val := m.GetMaxResults(); val < 1 || val > 100 {
		err := QueryParametersValidationError{
			field:  "MaxResults",
			reason: "value must be inside range [1, 100]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetSimilarityThreshold(); val < 0 || val > 1 {
		err := QueryParametersValidationError{
			field:  "SimilarityThreshold",
			reason: "value must be inside range [0, 1]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Filters

	// no validation rules for EnableReranking

	// no validation rules for EnableContextAssembly

	// no validation rules for MaxContextLength

	if len(errors) > 0 {
		return QueryParametersMultiError(errors)
	}

	return nil
}

// QueryParametersMultiError is an error wrapping multiple validation errors
// returned by QueryParameters.ValidateAll() if the designated constraints
// aren't met.
type QueryParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryParametersMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryParametersMultiError) AllErrors() []error { return m }

// QueryParametersValidationError is the validation error returned by
// QueryParameters.Validate if the designated constraints aren't met.
type QueryParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryParametersValidationError) ErrorName() string { return "QueryParametersValidationError" }

// Error satisfies the builtin error interface
func (e QueryParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryParameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryParametersValidationError{}

// Validate checks the field values on QueryResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryResponseMultiError, or
// nil if none found.
func (m *QueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for QueryId

	// no validation rules for Answer

	for idx, item := range m.GetRelatedDocuments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryResponseValidationError{
						field:  fmt.Sprintf("RelatedDocuments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryResponseValidationError{
						field:  fmt.Sprintf("RelatedDocuments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryResponseValidationError{
					field:  fmt.Sprintf("RelatedDocuments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryResponseValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueryResponseMultiError(errors)
	}

	return nil
}

// QueryResponseMultiError is an error wrapping multiple validation errors
// returned by QueryResponse.ValidateAll() if the designated constraints
// aren't met.
type QueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryResponseMultiError) AllErrors() []error { return m }

// QueryResponseValidationError is the validation error returned by
// QueryResponse.Validate if the designated constraints aren't met.
type QueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryResponseValidationError) ErrorName() string { return "QueryResponseValidationError" }

// Error satisfies the builtin error interface
func (e QueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryResponseValidationError{}

// Validate checks the field values on RelatedDocument with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RelatedDocument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelatedDocument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RelatedDocumentMultiError, or nil if none found.
func (m *RelatedDocument) ValidateAll() error {
	return m.validate(true)
}

func (m *RelatedDocument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocumentId

	// no validation rules for Title

	// no validation rules for Snippet

	// no validation rules for RelevanceScore

	// no validation rules for DocumentType

	for idx, item := range m.GetChunks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RelatedDocumentValidationError{
						field:  fmt.Sprintf("Chunks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RelatedDocumentValidationError{
						field:  fmt.Sprintf("Chunks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RelatedDocumentValidationError{
					field:  fmt.Sprintf("Chunks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RelatedDocumentMultiError(errors)
	}

	return nil
}

// RelatedDocumentMultiError is an error wrapping multiple validation errors
// returned by RelatedDocument.ValidateAll() if the designated constraints
// aren't met.
type RelatedDocumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelatedDocumentMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelatedDocumentMultiError) AllErrors() []error { return m }

// RelatedDocumentValidationError is the validation error returned by
// RelatedDocument.Validate if the designated constraints aren't met.
type RelatedDocumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelatedDocumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelatedDocumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelatedDocumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelatedDocumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelatedDocumentValidationError) ErrorName() string { return "RelatedDocumentValidationError" }

// Error satisfies the builtin error interface
func (e RelatedDocumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelatedDocument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelatedDocumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelatedDocumentValidationError{}

// Validate checks the field values on QueryMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueryMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueryMetadataMultiError, or
// nil if none found.
func (m *QueryMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueryTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueryMetadataValidationError{
					field:  "QueryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueryMetadataValidationError{
					field:  "QueryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueryTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueryMetadataValidationError{
				field:  "QueryTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ProcessingTimeMs

	// no validation rules for TotalDocumentsSearched

	// no validation rules for DocumentsReturned

	// no validation rules for ModelUsed

	// no validation rules for DebugInfo

	if len(errors) > 0 {
		return QueryMetadataMultiError(errors)
	}

	return nil
}

// QueryMetadataMultiError is an error wrapping multiple validation errors
// returned by QueryMetadata.ValidateAll() if the designated constraints
// aren't met.
type QueryMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMetadataMultiError) AllErrors() []error { return m }

// QueryMetadataValidationError is the validation error returned by
// QueryMetadata.Validate if the designated constraints aren't met.
type QueryMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryMetadataValidationError) ErrorName() string { return "QueryMetadataValidationError" }

// Error satisfies the builtin error interface
func (e QueryMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryMetadataValidationError{}

// Validate checks the field values on UploadDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UploadDocumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UploadDocumentRequestMultiError, or nil if none found.
func (m *UploadDocumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadDocumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetFileContent()) < 1 {
		err := UploadDocumentRequestValidationError{
			field:  "FileContent",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTitle()) < 1 {
		err := UploadDocumentRequestValidationError{
			field:  "Title",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFileType()) < 1 {
		err := UploadDocumentRequestValidationError{
			field:  "FileType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UploadDocumentRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UploadDocumentRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UploadDocumentRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProcessingOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UploadDocumentRequestValidationError{
					field:  "ProcessingOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UploadDocumentRequestValidationError{
					field:  "ProcessingOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProcessingOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UploadDocumentRequestValidationError{
				field:  "ProcessingOptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UploadDocumentRequestMultiError(errors)
	}

	return nil
}

// UploadDocumentRequestMultiError is an error wrapping multiple validation
// errors returned by UploadDocumentRequest.ValidateAll() if the designated
// constraints aren't met.
type UploadDocumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadDocumentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadDocumentRequestMultiError) AllErrors() []error { return m }

// UploadDocumentRequestValidationError is the validation error returned by
// UploadDocumentRequest.Validate if the designated constraints aren't met.
type UploadDocumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadDocumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadDocumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadDocumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadDocumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadDocumentRequestValidationError) ErrorName() string {
	return "UploadDocumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UploadDocumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadDocumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadDocumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadDocumentRequestValidationError{}

// Validate checks the field values on DocumentProcessingOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentProcessingOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentProcessingOptions with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentProcessingOptionsMultiError, or nil if none found.
func (m *DocumentProcessingOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentProcessingOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChunkStrategy

	if val := m.GetChunkSize(); val < 100 || val > 2000 {
		err := DocumentProcessingOptionsValidationError{
			field:  "ChunkSize",
			reason: "value must be inside range [100, 2000]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetChunkOverlap(); val < 0 || val > 500 {
		err := DocumentProcessingOptionsValidationError{
			field:  "ChunkOverlap",
			reason: "value must be inside range [0, 500]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for EmbeddingModel

	// no validation rules for EnableOcr

	// no validation rules for Language

	if len(errors) > 0 {
		return DocumentProcessingOptionsMultiError(errors)
	}

	return nil
}

// DocumentProcessingOptionsMultiError is an error wrapping multiple validation
// errors returned by DocumentProcessingOptions.ValidateAll() if the
// designated constraints aren't met.
type DocumentProcessingOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentProcessingOptionsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentProcessingOptionsMultiError) AllErrors() []error { return m }

// DocumentProcessingOptionsValidationError is the validation error returned by
// DocumentProcessingOptions.Validate if the designated constraints aren't met.
type DocumentProcessingOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentProcessingOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentProcessingOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentProcessingOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentProcessingOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentProcessingOptionsValidationError) ErrorName() string {
	return "DocumentProcessingOptionsValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentProcessingOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentProcessingOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentProcessingOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentProcessingOptionsValidationError{}

// Validate checks the field values on UploadDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UploadDocumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UploadDocumentResponseMultiError, or nil if none found.
func (m *UploadDocumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadDocumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocumentId

	// no validation rules for UploadStatus

	if all {
		switch v := interface{}(m.GetProgress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UploadDocumentResponseValidationError{
					field:  "Progress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UploadDocumentResponseValidationError{
					field:  "Progress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProgress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UploadDocumentResponseValidationError{
				field:  "Progress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDocumentInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UploadDocumentResponseValidationError{
					field:  "DocumentInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UploadDocumentResponseValidationError{
					field:  "DocumentInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocumentInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UploadDocumentResponseValidationError{
				field:  "DocumentInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UploadDocumentResponseMultiError(errors)
	}

	return nil
}

// UploadDocumentResponseMultiError is an error wrapping multiple validation
// errors returned by UploadDocumentResponse.ValidateAll() if the designated
// constraints aren't met.
type UploadDocumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadDocumentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadDocumentResponseMultiError) AllErrors() []error { return m }

// UploadDocumentResponseValidationError is the validation error returned by
// UploadDocumentResponse.Validate if the designated constraints aren't met.
type UploadDocumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadDocumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadDocumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadDocumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadDocumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadDocumentResponseValidationError) ErrorName() string {
	return "UploadDocumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UploadDocumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadDocumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadDocumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadDocumentResponseValidationError{}

// Validate checks the field values on DocumentProcessingProgress with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DocumentProcessingProgress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentProcessingProgress with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentProcessingProgressMultiError, or nil if none found.
func (m *DocumentProcessingProgress) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentProcessingProgress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProgressPercentage

	// no validation rules for CurrentStage

	// no validation rules for StatusMessage

	if all {
		switch v := interface{}(m.GetStartedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentProcessingProgressValidationError{
					field:  "StartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentProcessingProgressValidationError{
					field:  "StartedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentProcessingProgressValidationError{
				field:  "StartedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEstimatedCompletion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentProcessingProgressValidationError{
					field:  "EstimatedCompletion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentProcessingProgressValidationError{
					field:  "EstimatedCompletion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEstimatedCompletion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentProcessingProgressValidationError{
				field:  "EstimatedCompletion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentProcessingProgressMultiError(errors)
	}

	return nil
}

// DocumentProcessingProgressMultiError is an error wrapping multiple
// validation errors returned by DocumentProcessingProgress.ValidateAll() if
// the designated constraints aren't met.
type DocumentProcessingProgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentProcessingProgressMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentProcessingProgressMultiError) AllErrors() []error { return m }

// DocumentProcessingProgressValidationError is the validation error returned
// by DocumentProcessingProgress.Validate if the designated constraints aren't met.
type DocumentProcessingProgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentProcessingProgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentProcessingProgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentProcessingProgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentProcessingProgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentProcessingProgressValidationError) ErrorName() string {
	return "DocumentProcessingProgressValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentProcessingProgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentProcessingProgress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentProcessingProgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentProcessingProgressValidationError{}

// Validate checks the field values on GetDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDocumentRequestMultiError, or nil if none found.
func (m *GetDocumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDocumentId()) < 1 {
		err := GetDocumentRequestValidationError{
			field:  "DocumentId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetDocumentRequestMultiError(errors)
	}

	return nil
}

// GetDocumentRequestMultiError is an error wrapping multiple validation errors
// returned by GetDocumentRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDocumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocumentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocumentRequestMultiError) AllErrors() []error { return m }

// GetDocumentRequestValidationError is the validation error returned by
// GetDocumentRequest.Validate if the designated constraints aren't met.
type GetDocumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocumentRequestValidationError) ErrorName() string {
	return "GetDocumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocumentRequestValidationError{}

// Validate checks the field values on GetDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDocumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDocumentResponseMultiError, or nil if none found.
func (m *GetDocumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDocumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDocumentInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDocumentResponseValidationError{
					field:  "DocumentInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDocumentResponseValidationError{
					field:  "DocumentInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDocumentInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDocumentResponseValidationError{
				field:  "DocumentInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Content

	for idx, item := range m.GetChunks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDocumentResponseValidationError{
						field:  fmt.Sprintf("Chunks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDocumentResponseValidationError{
						field:  fmt.Sprintf("Chunks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDocumentResponseValidationError{
					field:  fmt.Sprintf("Chunks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDocumentResponseValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDocumentResponseValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDocumentResponseValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDocumentResponseMultiError(errors)
	}

	return nil
}

// GetDocumentResponseMultiError is an error wrapping multiple validation
// errors returned by GetDocumentResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDocumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDocumentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDocumentResponseMultiError) AllErrors() []error { return m }

// GetDocumentResponseValidationError is the validation error returned by
// GetDocumentResponse.Validate if the designated constraints aren't met.
type GetDocumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDocumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDocumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDocumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDocumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDocumentResponseValidationError) ErrorName() string {
	return "GetDocumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDocumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDocumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDocumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDocumentResponseValidationError{}

// Validate checks the field values on DocumentStats with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DocumentStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentStats with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DocumentStatsMultiError, or
// nil if none found.
func (m *DocumentStats) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalChunks

	// no validation rules for TotalTokens

	// no validation rules for AverageChunkSize

	// no validation rules for QueryCount

	if all {
		switch v := interface{}(m.GetLastAccessed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DocumentStatsValidationError{
					field:  "LastAccessed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DocumentStatsValidationError{
					field:  "LastAccessed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastAccessed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DocumentStatsValidationError{
				field:  "LastAccessed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DocumentStatsMultiError(errors)
	}

	return nil
}

// DocumentStatsMultiError is an error wrapping multiple validation errors
// returned by DocumentStats.ValidateAll() if the designated constraints
// aren't met.
type DocumentStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentStatsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentStatsMultiError) AllErrors() []error { return m }

// DocumentStatsValidationError is the validation error returned by
// DocumentStats.Validate if the designated constraints aren't met.
type DocumentStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentStatsValidationError) ErrorName() string { return "DocumentStatsValidationError" }

// Error satisfies the builtin error interface
func (e DocumentStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentStatsValidationError{}

// Validate checks the field values on DeleteDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDocumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDocumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDocumentRequestMultiError, or nil if none found.
func (m *DeleteDocumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDocumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDocumentId()) < 1 {
		err := DeleteDocumentRequestValidationError{
			field:  "DocumentId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDocumentRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDocumentRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDocumentRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteDocumentRequestMultiError(errors)
	}

	return nil
}

// DeleteDocumentRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteDocumentRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteDocumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDocumentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDocumentRequestMultiError) AllErrors() []error { return m }

// DeleteDocumentRequestValidationError is the validation error returned by
// DeleteDocumentRequest.Validate if the designated constraints aren't met.
type DeleteDocumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDocumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDocumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDocumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDocumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDocumentRequestValidationError) ErrorName() string {
	return "DeleteDocumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDocumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDocumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDocumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDocumentRequestValidationError{}

// Validate checks the field values on DeleteOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteOptionsMultiError, or
// nil if none found.
func (m *DeleteOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ForceDelete

	// no validation rules for DeleteRelatedChunks

	// no validation rules for DeleteEmbeddings

	// no validation rules for Reason

	if len(errors) > 0 {
		return DeleteOptionsMultiError(errors)
	}

	return nil
}

// DeleteOptionsMultiError is an error wrapping multiple validation errors
// returned by DeleteOptions.ValidateAll() if the designated constraints
// aren't met.
type DeleteOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteOptionsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteOptionsMultiError) AllErrors() []error { return m }

// DeleteOptionsValidationError is the validation error returned by
// DeleteOptions.Validate if the designated constraints aren't met.
type DeleteOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteOptionsValidationError) ErrorName() string { return "DeleteOptionsValidationError" }

// Error satisfies the builtin error interface
func (e DeleteOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteOptionsValidationError{}

// Validate checks the field values on DeleteDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteDocumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteDocumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteDocumentResponseMultiError, or nil if none found.
func (m *DeleteDocumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteDocumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetCleanupInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteDocumentResponseValidationError{
					field:  "CleanupInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteDocumentResponseValidationError{
					field:  "CleanupInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCleanupInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteDocumentResponseValidationError{
				field:  "CleanupInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteDocumentResponseMultiError(errors)
	}

	return nil
}

// DeleteDocumentResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteDocumentResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteDocumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDocumentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDocumentResponseMultiError) AllErrors() []error { return m }

// DeleteDocumentResponseValidationError is the validation error returned by
// DeleteDocumentResponse.Validate if the designated constraints aren't met.
type DeleteDocumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDocumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDocumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDocumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDocumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDocumentResponseValidationError) ErrorName() string {
	return "DeleteDocumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDocumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDocumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDocumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDocumentResponseValidationError{}

// Validate checks the field values on CleanupInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CleanupInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CleanupInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CleanupInfoMultiError, or
// nil if none found.
func (m *CleanupInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CleanupInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChunksDeleted

	// no validation rules for EmbeddingsDeleted

	// no validation rules for StorageFreedBytes

	if all {
		switch v := interface{}(m.GetDeletionCompletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CleanupInfoValidationError{
					field:  "DeletionCompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CleanupInfoValidationError{
					field:  "DeletionCompletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletionCompletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CleanupInfoValidationError{
				field:  "DeletionCompletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CleanupInfoMultiError(errors)
	}

	return nil
}

// CleanupInfoMultiError is an error wrapping multiple validation errors
// returned by CleanupInfo.ValidateAll() if the designated constraints aren't met.
type CleanupInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CleanupInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CleanupInfoMultiError) AllErrors() []error { return m }

// CleanupInfoValidationError is the validation error returned by
// CleanupInfo.Validate if the designated constraints aren't met.
type CleanupInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CleanupInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CleanupInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CleanupInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CleanupInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CleanupInfoValidationError) ErrorName() string { return "CleanupInfoValidationError" }

// Error satisfies the builtin error interface
func (e CleanupInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCleanupInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CleanupInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CleanupInfoValidationError{}

// Validate checks the field values on ListDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDocumentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDocumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDocumentsRequestMultiError, or nil if none found.
func (m *ListDocumentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDocumentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDocumentsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDocumentsRequestValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDocumentsRequestValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetFilters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDocumentsRequestValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDocumentsRequestValidationError{
						field:  fmt.Sprintf("Filters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDocumentsRequestValidationError{
					field:  fmt.Sprintf("Filters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSorts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDocumentsRequestValidationError{
						field:  fmt.Sprintf("Sorts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDocumentsRequestValidationError{
						field:  fmt.Sprintf("Sorts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDocumentsRequestValidationError{
					field:  fmt.Sprintf("Sorts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListDocumentsRequestMultiError(errors)
	}

	return nil
}

// ListDocumentsRequestMultiError is an error wrapping multiple validation
// errors returned by ListDocumentsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListDocumentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDocumentsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDocumentsRequestMultiError) AllErrors() []error { return m }

// ListDocumentsRequestValidationError is the validation error returned by
// ListDocumentsRequest.Validate if the designated constraints aren't met.
type ListDocumentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDocumentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDocumentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDocumentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDocumentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDocumentsRequestValidationError) ErrorName() string {
	return "ListDocumentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDocumentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDocumentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDocumentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDocumentsRequestValidationError{}

// Validate checks the field values on ListDocumentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDocumentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDocumentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDocumentsResponseMultiError, or nil if none found.
func (m *ListDocumentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDocumentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDocuments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListDocumentsResponseValidationError{
						field:  fmt.Sprintf("Documents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListDocumentsResponseValidationError{
						field:  fmt.Sprintf("Documents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListDocumentsResponseValidationError{
					field:  fmt.Sprintf("Documents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDocumentsResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDocumentsResponseValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDocumentsResponseValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDocumentsResponseValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDocumentsResponseValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDocumentsResponseValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListDocumentsResponseMultiError(errors)
	}

	return nil
}

// ListDocumentsResponseMultiError is an error wrapping multiple validation
// errors returned by ListDocumentsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListDocumentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDocumentsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDocumentsResponseMultiError) AllErrors() []error { return m }

// ListDocumentsResponseValidationError is the validation error returned by
// ListDocumentsResponse.Validate if the designated constraints aren't met.
type ListDocumentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDocumentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDocumentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDocumentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDocumentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDocumentsResponseValidationError) ErrorName() string {
	return "ListDocumentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDocumentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDocumentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDocumentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDocumentsResponseValidationError{}

// Validate checks the field values on DocumentListStats with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DocumentListStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DocumentListStats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DocumentListStatsMultiError, or nil if none found.
func (m *DocumentListStats) ValidateAll() error {
	return m.validate(true)
}

func (m *DocumentListStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalDocuments

	// no validation rules for TotalSizeBytes

	// no validation rules for TotalChunks

	// no validation rules for DocumentsByType

	if len(errors) > 0 {
		return DocumentListStatsMultiError(errors)
	}

	return nil
}

// DocumentListStatsMultiError is an error wrapping multiple validation errors
// returned by DocumentListStats.ValidateAll() if the designated constraints
// aren't met.
type DocumentListStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DocumentListStatsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DocumentListStatsMultiError) AllErrors() []error { return m }

// DocumentListStatsValidationError is the validation error returned by
// DocumentListStats.Validate if the designated constraints aren't met.
type DocumentListStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DocumentListStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DocumentListStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DocumentListStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DocumentListStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DocumentListStatsValidationError) ErrorName() string {
	return "DocumentListStatsValidationError"
}

// Error satisfies the builtin error interface
func (e DocumentListStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDocumentListStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DocumentListStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DocumentListStatsValidationError{}

// Validate checks the field values on UpdateDocumentMetadataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDocumentMetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDocumentMetadataRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDocumentMetadataRequestMultiError, or nil if none found.
func (m *UpdateDocumentMetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDocumentMetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetDocumentId()) < 1 {
		err := UpdateDocumentMetadataRequestValidationError{
			field:  "DocumentId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDocumentMetadataRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDocumentMetadataRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDocumentMetadataRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateDocumentMetadataRequestMultiError(errors)
	}

	return nil
}

// UpdateDocumentMetadataRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDocumentMetadataRequest.ValidateAll()
// if the designated constraints aren't met.
type UpdateDocumentMetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDocumentMetadataRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDocumentMetadataRequestMultiError) AllErrors() []error { return m }

// UpdateDocumentMetadataRequestValidationError is the validation error
// returned by UpdateDocumentMetadataRequest.Validate if the designated
// constraints aren't met.
type UpdateDocumentMetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDocumentMetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDocumentMetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDocumentMetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDocumentMetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDocumentMetadataRequestValidationError) ErrorName() string {
	return "UpdateDocumentMetadataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDocumentMetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDocumentMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDocumentMetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDocumentMetadataRequestValidationError{}

// Validate checks the field values on UpdateDocumentMetadataResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDocumentMetadataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDocumentMetadataResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDocumentMetadataResponseMultiError, or nil if none found.
func (m *UpdateDocumentMetadataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDocumentMetadataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetUpdatedMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDocumentMetadataResponseValidationError{
					field:  "UpdatedMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDocumentMetadataResponseValidationError{
					field:  "UpdatedMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDocumentMetadataResponseValidationError{
				field:  "UpdatedMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MetadataVersion

	if len(errors) > 0 {
		return UpdateDocumentMetadataResponseMultiError(errors)
	}

	return nil
}

// UpdateDocumentMetadataResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDocumentMetadataResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateDocumentMetadataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDocumentMetadataResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDocumentMetadataResponseMultiError) AllErrors() []error { return m }

// UpdateDocumentMetadataResponseValidationError is the validation error
// returned by UpdateDocumentMetadataResponse.Validate if the designated
// constraints aren't met.
type UpdateDocumentMetadataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDocumentMetadataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDocumentMetadataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDocumentMetadataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDocumentMetadataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDocumentMetadataResponseValidationError) ErrorName() string {
	return "UpdateDocumentMetadataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDocumentMetadataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDocumentMetadataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDocumentMetadataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDocumentMetadataResponseValidationError{}
