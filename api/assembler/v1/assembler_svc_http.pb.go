// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.9.0
// - protoc             v3.21.12
// source: v1/assembler_svc.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	v1 "rag/api/common/v1"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationAssemblerAssembleBatchContexts = "/api.assembler.v1.Assembler/AssembleBatchContexts"
const OperationAssemblerAssembleContext = "/api.assembler.v1.Assembler/AssembleContext"
const OperationAssemblerEstimateTokens = "/api.assembler.v1.Assembler/EstimateTokens"
const OperationAssemblerHealthCheck = "/api.assembler.v1.Assembler/HealthCheck"
const OperationAssemblerListTemplates = "/api.assembler.v1.Assembler/ListTemplates"
const OperationAssemblerOptimizeContent = "/api.assembler.v1.Assembler/OptimizeContent"
const OperationAssemblerRenderTemplate = "/api.assembler.v1.Assembler/RenderTemplate"
const OperationAssemblerSplitContent = "/api.assembler.v1.Assembler/SplitContent"

type AssemblerHTTPServer interface {
	// AssembleBatchContexts 批量上下文构建
	AssembleBatchContexts(context.Context, *AssembleBatchContextsRequest) (*AssembleBatchContextsResponse, error)
	// AssembleContext 构建上下文
	AssembleContext(context.Context, *AssembleContextRequest) (*AssembleContextResponse, error)
	// EstimateTokens 估算Token数量
	EstimateTokens(context.Context, *EstimateTokensRequest) (*EstimateTokensResponse, error)
	// HealthCheck 健康检查
	HealthCheck(context.Context, *emptypb.Empty) (*v1.HealthCheckResponse, error)
	// ListTemplates 获取模板列表
	ListTemplates(context.Context, *ListTemplatesRequest) (*ListTemplatesResponse, error)
	// OptimizeContent 内容优化
	OptimizeContent(context.Context, *OptimizeContentRequest) (*OptimizeContentResponse, error)
	// RenderTemplate 模板渲染
	RenderTemplate(context.Context, *RenderTemplateRequest) (*RenderTemplateResponse, error)
	// SplitContent 分割长文本
	SplitContent(context.Context, *SplitContentRequest) (*SplitContentResponse, error)
}

func RegisterAssemblerHTTPServer(s *http.Server, srv AssemblerHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/assemble/context", _Assembler_AssembleContext0_HTTP_Handler(srv))
	r.POST("/v1/tokens/estimate", _Assembler_EstimateTokens0_HTTP_Handler(srv))
	r.POST("/v1/optimize/content", _Assembler_OptimizeContent0_HTTP_Handler(srv))
	r.POST("/v1/split/content", _Assembler_SplitContent0_HTTP_Handler(srv))
	r.POST("/v1/render/template", _Assembler_RenderTemplate0_HTTP_Handler(srv))
	r.POST("/v1/assemble/batch", _Assembler_AssembleBatchContexts0_HTTP_Handler(srv))
	r.GET("/v1/templates", _Assembler_ListTemplates0_HTTP_Handler(srv))
	r.GET("/v1/health", _Assembler_HealthCheck0_HTTP_Handler(srv))
}

func _Assembler_AssembleContext0_HTTP_Handler(srv AssemblerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AssembleContextRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAssemblerAssembleContext)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AssembleContext(ctx, req.(*AssembleContextRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AssembleContextResponse)
		return ctx.Result(200, reply)
	}
}

func _Assembler_EstimateTokens0_HTTP_Handler(srv AssemblerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in EstimateTokensRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAssemblerEstimateTokens)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.EstimateTokens(ctx, req.(*EstimateTokensRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*EstimateTokensResponse)
		return ctx.Result(200, reply)
	}
}

func _Assembler_OptimizeContent0_HTTP_Handler(srv AssemblerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in OptimizeContentRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAssemblerOptimizeContent)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.OptimizeContent(ctx, req.(*OptimizeContentRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OptimizeContentResponse)
		return ctx.Result(200, reply)
	}
}

func _Assembler_SplitContent0_HTTP_Handler(srv AssemblerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SplitContentRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAssemblerSplitContent)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SplitContent(ctx, req.(*SplitContentRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SplitContentResponse)
		return ctx.Result(200, reply)
	}
}

func _Assembler_RenderTemplate0_HTTP_Handler(srv AssemblerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RenderTemplateRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAssemblerRenderTemplate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RenderTemplate(ctx, req.(*RenderTemplateRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RenderTemplateResponse)
		return ctx.Result(200, reply)
	}
}

func _Assembler_AssembleBatchContexts0_HTTP_Handler(srv AssemblerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AssembleBatchContextsRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAssemblerAssembleBatchContexts)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AssembleBatchContexts(ctx, req.(*AssembleBatchContextsRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AssembleBatchContextsResponse)
		return ctx.Result(200, reply)
	}
}

func _Assembler_ListTemplates0_HTTP_Handler(srv AssemblerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListTemplatesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAssemblerListTemplates)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListTemplates(ctx, req.(*ListTemplatesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListTemplatesResponse)
		return ctx.Result(200, reply)
	}
}

func _Assembler_HealthCheck0_HTTP_Handler(srv AssemblerHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in emptypb.Empty
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationAssemblerHealthCheck)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.HealthCheck(ctx, req.(*emptypb.Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.HealthCheckResponse)
		return ctx.Result(200, reply)
	}
}

type AssemblerHTTPClient interface {
	// AssembleBatchContexts 批量上下文构建
	AssembleBatchContexts(ctx context.Context, req *AssembleBatchContextsRequest, opts ...http.CallOption) (rsp *AssembleBatchContextsResponse, err error)
	// AssembleContext 构建上下文
	AssembleContext(ctx context.Context, req *AssembleContextRequest, opts ...http.CallOption) (rsp *AssembleContextResponse, err error)
	// EstimateTokens 估算Token数量
	EstimateTokens(ctx context.Context, req *EstimateTokensRequest, opts ...http.CallOption) (rsp *EstimateTokensResponse, err error)
	// HealthCheck 健康检查
	HealthCheck(ctx context.Context, req *emptypb.Empty, opts ...http.CallOption) (rsp *v1.HealthCheckResponse, err error)
	// ListTemplates 获取模板列表
	ListTemplates(ctx context.Context, req *ListTemplatesRequest, opts ...http.CallOption) (rsp *ListTemplatesResponse, err error)
	// OptimizeContent 内容优化
	OptimizeContent(ctx context.Context, req *OptimizeContentRequest, opts ...http.CallOption) (rsp *OptimizeContentResponse, err error)
	// RenderTemplate 模板渲染
	RenderTemplate(ctx context.Context, req *RenderTemplateRequest, opts ...http.CallOption) (rsp *RenderTemplateResponse, err error)
	// SplitContent 分割长文本
	SplitContent(ctx context.Context, req *SplitContentRequest, opts ...http.CallOption) (rsp *SplitContentResponse, err error)
}

type AssemblerHTTPClientImpl struct {
	cc *http.Client
}

func NewAssemblerHTTPClient(client *http.Client) AssemblerHTTPClient {
	return &AssemblerHTTPClientImpl{client}
}

// AssembleBatchContexts 批量上下文构建
func (c *AssemblerHTTPClientImpl) AssembleBatchContexts(ctx context.Context, in *AssembleBatchContextsRequest, opts ...http.CallOption) (*AssembleBatchContextsResponse, error) {
	var out AssembleBatchContextsResponse
	pattern := "/v1/assemble/batch"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAssemblerAssembleBatchContexts))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// AssembleContext 构建上下文
func (c *AssemblerHTTPClientImpl) AssembleContext(ctx context.Context, in *AssembleContextRequest, opts ...http.CallOption) (*AssembleContextResponse, error) {
	var out AssembleContextResponse
	pattern := "/v1/assemble/context"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAssemblerAssembleContext))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// EstimateTokens 估算Token数量
func (c *AssemblerHTTPClientImpl) EstimateTokens(ctx context.Context, in *EstimateTokensRequest, opts ...http.CallOption) (*EstimateTokensResponse, error) {
	var out EstimateTokensResponse
	pattern := "/v1/tokens/estimate"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAssemblerEstimateTokens))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// HealthCheck 健康检查
func (c *AssemblerHTTPClientImpl) HealthCheck(ctx context.Context, in *emptypb.Empty, opts ...http.CallOption) (*v1.HealthCheckResponse, error) {
	var out v1.HealthCheckResponse
	pattern := "/v1/health"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationAssemblerHealthCheck))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// ListTemplates 获取模板列表
func (c *AssemblerHTTPClientImpl) ListTemplates(ctx context.Context, in *ListTemplatesRequest, opts ...http.CallOption) (*ListTemplatesResponse, error) {
	var out ListTemplatesResponse
	pattern := "/v1/templates"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationAssemblerListTemplates))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// OptimizeContent 内容优化
func (c *AssemblerHTTPClientImpl) OptimizeContent(ctx context.Context, in *OptimizeContentRequest, opts ...http.CallOption) (*OptimizeContentResponse, error) {
	var out OptimizeContentResponse
	pattern := "/v1/optimize/content"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAssemblerOptimizeContent))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// RenderTemplate 模板渲染
func (c *AssemblerHTTPClientImpl) RenderTemplate(ctx context.Context, in *RenderTemplateRequest, opts ...http.CallOption) (*RenderTemplateResponse, error) {
	var out RenderTemplateResponse
	pattern := "/v1/render/template"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAssemblerRenderTemplate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

// SplitContent 分割长文本
func (c *AssemblerHTTPClientImpl) SplitContent(ctx context.Context, in *SplitContentRequest, opts ...http.CallOption) (*SplitContentResponse, error) {
	var out SplitContentResponse
	pattern := "/v1/split/content"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationAssemblerSplitContent))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
